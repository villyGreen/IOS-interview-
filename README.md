# IOS-interview
It is useful guide for future IOS interview 

<img src="https://c.tenor.com/-ZBHzqh79q8AAAAS/%D0%B8%D0%B4%D1%83%D1%89%D0%B8%D0%B9%D0%BA%D1%80%D0%B5%D0%BA%D0%B5-%D0%BF%D1%80%D0%B5%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D0%BB%D1%81%D1%8F.gif"/>
Hi, in this file i collected many useful information, then can be halped for your technical interview

## Overview:
- Value Semantics
- Memmory management
- Copy On Write
- Collections
- Multithreading
- Dispatching
- Difference between setNeedsLayout and layoutIfNeeded
- App Life Cycle
- View Controller Life Cycle
- UIKit

# Swift Value Semantics
  В языке Swift имеется два вида значений:
  1) Ссылочный тип (классы, clousers)
  2) Тип значения (структуры, перечисления)
  
Ссылочный тип - тип, который хранит в себе указатель на обьект (адресс этого обьекта на каком-то участке памяти), хранится на куче (динамическая память), при этом сам указатель хранится в стеке 
 
Тип значения - хранится на стеке (статическая память). Есть два сценария когда value type не будет хранится на стеке:
a) Когда внутри value type есть reference.
b) когда type конформит какой-нибудь проток.
с) когда захватывается в блоке и мутируется.
Если размер value type слишком большой, то происходит inline optimization и он переходи на кучу, а в стеке остается только указатель на него. Для value type характерен механизм cow (Copy on write)
### Стек и Куча

Стек используется для статического выделения памяти, а куча — для динамического выделения памяти, которые хранятся в оперативной памяти компьютера.

Переменные, размещенные в стеке, хранятся непосредственно в памяти, и доступ к этой памяти очень быстрый, а ее выделение определяется при компиляции программы. Когда функция или метод вызывает другую функцию, которая, в свою очередь, вызывает другую функцию и т. д., выполнение всех этих функций приостанавливается до тех пор, пока самая последняя функция не вернет свое значение. Стек всегда резервируется в порядке LIFO, самый последний зарезервированный блок всегда является следующим освобождаемым блоком. Это упрощает отслеживание стека. Освобождение блока из стека — это не что иное, как корректировка одного указателя.

- Для работы со стеком есть 2 основные команды:
      - Push - поместить данные на вершину стека, тем самым увеличиваем stack ponter.
      - Pop - извлечь данные с вершины стека, тем самым уменьшаем stack pointer.
   - Операции со стеком:
      - Включение 
      - Исключение
      - Определение размера
      - Очистка
      - Неразрушающее чтение
      
  ### Куча (Heap) 
   - Тип данных - ссылочный **Reference Type**, древовидная структура данных, где выделение памяти из ОС происходит по требованию приложения, используется для динамического выделения памяти и аллоцируется во время работы программы (рантайм). После выделения памяти в распоряжении программы поступает указатель на начало выделенной памяти. 
   - Все данные в куче располагаются линейно, т.е от начала её памяти к её концу, в сторону увеличения адресов.
   - Classes|Closures|Functions|Indirect Enums|Actors - хранятся на куче.
   - Передаются по ссылке, при присвоении.
   - Куча общая для всех потоков приложения.    

![image](https://i.stack.imgur.com/gKoxc.png)

# Memory Management
Обьект находятся в памяти до тех пор, пока на него ссылается хоть одна сильная ссылка, для избежания retain-cycle (обьекты ссылаются друг на друга, и не могут быть освобожденны из памяти) применяются weak и unowned ссылка

## Memmory Managenemt до Swift 4
До 4 версии swift, счетчик сильных слабых и сильных ссылок, хранился прямо в обьекте вместе со свойствами
Для примера возьмем следующею ситуацию:

1) На обьект указывает сильная и слабая ссылка
2) Сильная ссылка была уничтожена, данные обьекта уничтожаются, но память так и не была освобождена, обьект становится zombie (NSZombie) на который ссылается слабая ссылка
3) Как только будет обращение по этой ссылке, runtime проверит zombiie этот обьект или нет, если да - то уменьшит счетчик ссылок

Какие минусы:
 1) Неоптимизированное использование памяти, такие обьекты могут долго хранится в памяти
 2) Не потоко-безопасно:
  import Foundation

```
import Foundation
class Target {}
class WeakHolder {
   weak var weak: Target?
}
for i in 0..<1000000 {
   print(i)
   let holder = WeakHolder()
   holder.weak = Target()
   dispatch_async(dispatch_get_global_queue(0, 0), {
       let _ = holder.weak
   })
   dispatch_async(dispatch_get_global_queue(0, 0), {
       let _ = holder.weak
   })
}
```

Данный кусок кода может получить ошибку в **Runtime**. Суть именно в том механизме, который был рассмотрен ранее. Два потока могут одновременно обратиться к объекту по слабой ссылке. Перед тем, как получить объект, они проверяют, является ли проверяемый объект «зомби». И если оба потока получат ответ true, они отнимут счётчик и постараются освободить память. Один из них сделает это, а второй просто вызовет краш, так как попытается освободить уже освобожденный участок памяти.
Такая реализация не очень хороша и с этим нужно что-то делать.

## Memmory Managenemt сейчас
 В актуальной версии swift используется side tables. Side table - это область в памяти, которая хранит в себе информацию об колличестве ссылок на обьект.
 Как только мы начинаем ссылаться на объект слабо `weak reference` - то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу.

Сама боковая таблица также имеет ссылку на объект. Еще боковая таблица может создаваться, когда `происходит переполнение счетчика`, и он уже не помещается в поле (счетчики ссылок будут маленькими на 32-битных машинах).

С таким механизмом слабые ссылки ссылаются не напрямую на объект, а на боковую таблицу, которая указывает на объект. Это решает две предыдущие проблемы:
  - Экономие памяти: объект удаляется из памяти, если на него больше нет сильных ссылок.
  - Это позволяет безопасно обнулять слабые ссылки, поскольку слабая ссылка теперь не указывает напрямую на объект и не является предметом `race condition.`

Вот так **side table** выглядит:

```class HeapObjectSideTableEntry {
  std::atomic<HeapObject*> object;
  SideTableRefCounts refCounts;
}
```
  - В самом первом поле хранится указатель на объект, которому принадлежит эта **side table**. 
  - Следом лежит его счетчик ссылок, представленный структурой типа **SideTableRefCounts**. Внутри нее хранится битовое поле со счетчиками ссылок и флагами.

Счетчик ссылок хранится внутри структуры **HeapObject**. **HeapObject** – это внутреннее представление объекта в рантайме. То есть каждый экземпляр класса в рантайме это экземпляр структуры с типом **HeapObject**.

В алгоритме работы счетчика ссылок определено пять состояний, в которых объект находится на всем пути от создания до удаления из памяти. 
Можно провести параллель с жизненным циклом **UIViewController**. 
Он создается, отображает визуальные элементы, реагирует на вызовы от операционной системы и в конце деаллоцируется. 
Состояния объекта перечислены ниже:

1. `Live` – объект создан и находится в памяти.
2. `Deiniting` – объект находится в процессе деинициализации, то есть у него вызван метод `deinit`.
3. `Deinited` – объект полность деинициализирован.
4. `Freed` – выделенная память под объект освобождена, но `side table` еще существует.
5. `Dead` – память занятая side table освобождается.

![image](https://user-images.githubusercontent.com/47610132/176542135-43d31345-7d44-4197-bafa-96b37afc7e69.png)

  - `Live` его счетчики инициализируются со значениями strong — 1, unowned — 0, weak — 0 (weak появляется только с боковой таблицей). 
На данный момент нет боковой таблицы. Операции с **unowned** переменными работают нормально. Когда `strong reference count` достигает нуля, вызывается deinit(), и объект переходит в следующее состояние (deiniting).
  - `Deiniting` - на данном этапе операции со `strong` ссылками не действуют. При чтении через **unowned** ссылку будет срабатывать **assertion failure**. 
Но новые **unowned** ссылки еще могут добавляться. Если есть боковая таблица, то **weak** операции будут возвращать nil. Далее из этого состояния уже можно перейти в два других.
  - Если нет боковой таблицы, т.e нет `weak ссылок` и нет `unowned ссылок`, то объект переходит в `Dead` состояние и сразу удаляется из памяти.
  - Если у нас есть `unowned или weak ссылки`, объект переходит в состояние `Deinited`. 
В этом состоянии функция deinit() завершена, сохранение и чтение сильных или слабых ссылок невозможно. 
Как и сохранение новых `unowned ссылок`. При попытке чтения `unowned ссылки` вызывается assertion failure. Из этого состояния также возможно два исхода.
  - В случае наличия `weak ссылок`, а значит и боковой таблицы, осуществляется переход в состояние `Freed`. 
В `Freed` состоянии объект уже полностью освобожден и не занимает места в памяти, но его боковая таблица остается жива.
  - После того как счетчик слабых ссылок достигает нуля, боковая таблица также удаляется и освобождает память, и осуществляется переход в финальное состояние — `Dead`. 
В этом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на `HeapObject` освобождается из кучи, не оставляя следов объекта в памяти.

# Copy On Write
Copy in Write - механизм оптимизации памяти, когда мы скопировали обьект, то каждая ссылка указывает на один и тот же адрес памяти. Только когда одна из ссылок изменяет базовые данные, именно в этот момент, момент модификации, Swift фактически копирует исходный экземпляр и вносит изменения. То есть, будь то deep copy или shallow copy, новая копия не будет создана, пока мы не внесем изменения в один из объектов.

Пример:

```
func address(o: UnsafeRawPointer) { 
  print("address: \(Int(bitPattern: o))")
}

var arr1 = [1, 2, 3]
var arr2 = arr1

address(arr1)
address(arr2)
```

Результатом будет:
  ```
  address: 105553133388704
  address: 105553133388704
  
 ```

А теперь изменим второй массив:
   ```
   func address(o: UnsafeRawPointer) { 
  print("address: \(Int(bitPattern: o))")
  }

var arr1 = [1, 2, 3]
var arr2 = arr1

arr2.append(4)

address(arr1) 
address(arr2)
   
Резултат:
      address: 105553154755744
      address: 105553135788672
  ```
      
Увы, но даже не для всех структур из стандартной библиотеки он реализован, но точно реализован для основных типов, которые при копирование могут затратить большое количество ресурсов, а именно: String, Array, Dictionary и Set.

Становится очевидно, что для наших с вами собственных структур такой механизм тем более не предусмотрен, но - не беда, мы можем сделать его сами.

### Собственный COW
 ```
final class Ref<T> { 
  var val: T
	
  init(v: T) { 
    val = v
  } 
}

struct Box<T> {
  var ref: Ref<T>
	
  init(x: T) { 
    ref = Ref(x)
  }

	var value: T { 
    get {
      ref.val 
    }
    set {
      if (!isKnownUniquelyReferenced(&ref)) {
        ref = Ref(newValue) 
      } else {
        ref.val = newValue
      }
    } 
  }
}
 ```
Важным моментом является:
 ```
func isKnownUniquelyReferenced<T> (_ object: inout T?) -> Bool where T : AnyObject
 ```
 
 Данная реализация хранит наше value (в Box) одинаковым при переиспользование. Посмотрим на примере как этим пользоваться и каков будет результат. Для этого создадим нашу собственную структуру Test и один ее экземпляр.
 
  ```
 struct Test {
  var x: Int
}

let val = Test(x: 5)
// Ну и используем наш Box
var box = Box(val)
var box2 = box

address(&box.value) 
address(&box2.value)
 ```
 
 Резульат будет:
  ```
  address: 140701847686488
  address: 140701847686488
  ```
 

# Difference between setNeedsLayout and layoutIfNeeded
  У UIView есть методы, которые отвечают за изменения размеров и констрейнтов, один из методов - это LayoutSubviews()
 Для более понятного обьяснения, необходимо вспомнить life cycle view controller а именно методы:
 
ViewWillLayoutSubviews:
По умолчанию ничего не делает. Когда границы представления изменяются, представление корректирует положение своих подпредставлений. Контроллер представления может переопределить этот метод, чтобы внести изменения до того, как представление разместит свои подпредставления.

viewDidLayoutSubviews:
Этот метод вызывается после того, как viewController приспосабливается к своему подпредставлению после изменения его границы. Добавьте сюда код, если вы хотите внести изменения в подпредставления после того, как они были установлены.

Для примера создадим вью и применим к нему corner radius, все это будет происходить во viewDidLoad,  сожалению мы не увидим желаемый результат, т.к наше вью не обработало изменение размеров, для решения этой проблеммы мы могли весь этот код положить в метод viewDidLayoutSubviews - получим желаемый рузультат. 
Иногда нам нужно вызвать этот метод самостоятельно, для этого нам на помощь приходят setNeedLayoutSubview и layoutIfNeeded.
UIView.layoutIfNeeded() - Происходит новый перерасчет размеро и ограничений для всех subviews.
Пример: Есть вью, которая привязана к правому, левому, верхему краю констрейнтами и имеет констрейнт на ширину 200, мы хотим в блоке анимации умешьшать её высоту, для этого перед блоком анимации желательно вызвать view.layoutIfNeeded (рекомендация от Apple, для завершения всех предыдущих расчетов), и самом блоке анимации опять вызвать этот метод, как итог - мы получим плавно изменяющуюся высоту view 

<img src="https://i.stack.imgur.com/UB2AF.gif"/>

В чем сообственно разница между setNeedLayoutSubviews и layoutIfNeeded ?

Когда приложение iOS запускается, UIApplication в iOS запускает основной цикл выполнения для приложения, которое выполняется в основном потоке. Основной цикл выполнения обрабатывает события (например, касания пользователя) и обрабатывает обновления интерфейсов на основе представлений. По мере возникновения событий, таких как прикосновение, обновление местоположения, движение и управление мультимедиа, цикл выполнения находит подходящий обработчик для событий, вызывает соответствующие методы, которые вызывают другие методы и т. д. В какой-то момент времени все события будут обработаны, и управление вернется в цикл выполнения. Обозначим эту точку, где управление возвращается в цикл выполнения, как цикл обновления.

Пока события обрабатываются и запрашиваются некоторые изменения в представлении, эти изменения не обновляются немедленно. Вместо этого система ждет завершения существующего процесса и наступления следующего цикла перерисовки. Существует периодический интервал между обработкой события и обработкой обновления макета пользовательского интерфейса.

### setNeedsLayout

Метод setNeedsLayout для UIView сообщает системе, что вы хотите, чтобы она разметила и перерисовала это представление и все его подпредставления, когда придет время для цикла обновления. Это асинхронное действие, потому что метод завершается и возвращается немедленно, но макет и перерисовка фактически происходят только через какое-то время, и вы не знаете, когда будет этот цикл обновления.

### LayoutIfNeeded

Напротив, метод layoutIfNeeded являетсясинхронныйвызов, который сообщает системе, что вы хотите макет и перерисовку представления и его подвидов, и вы хотите, чтобы это было сделано немедленно, не дожидаясь цикла обновления. Когда вызов этого метода завершен, макет уже настроен и отрисован на основе всех изменений, которые были отмечены до вызова метода.


# App life cycle

![image](http://proswift.ru/wp-content/uploads/2015/10/AplicationLifeCycle_proSwift_ru.jpg)

Обработка событий из различных этапов жизненного цикла iOS приложений очень похожа на обработку событий жизненного цикла View Controller. Т.е. нужно понимать в какой момент какой метод вызывается и что в этот момент времени уже «проинициализировалось», — с чем мы можем в данный момент работать.

Сначала приложение не запущенно. Потом пользователь запускает приложение. Оно переходит в состояние в состояние Foreground, в котором приложение становится сначала Iactive —  на этом этапе выполняется код программы, но не обрабатываются события интерфейса пользователя (интерфейс не отображается, касания не обрабатываются и.т.п.). Затем переходит в этап Active, в котором выполняется код и обрабатываются все события UI.

Если пользователь запустит другое приложение, то текущее приложение перейдет в состояние Inactive и затем в состояние Background. В этом состоянии коды выполняется ограниченное время, и не обрабатываются события UI. Нужно понимать, что именно в этом состоянии можно заставить приложения получить, допустим, из интернета самые свежие обновления чего либо, и дать их приложению, что бы когда пользователь вернул приложение в Foreground он мог увидеть эту информацию.

После весьма короткого состояния Background  приложение переходит в состояние Suspended. В этом состоянии код не выполняется вовсе и система может убить приложение для освобождения памяти, если оно потребуется.

# UIViewController life cycle

### loadView
Этот метод используется, когда контроллер представления создается из кода. 
Это метод, управляемый viewController. ViewController вызывает его, когда его текущее представление равно нулю. loadView() в основном берет представление (которое вы создаете) и устанавливает его в представление viewController (суперпредставление).

### viewDidLoad

Этот метод загружается один раз в жизненном цикле контроллера представления. Он вызывается, когда загружаются все представления. В этом методе можно выполнить некоторые общие задачи:

### ViewWillAppear

Этот метод вызывается каждый раз перед тем, как представление становится видимым, и перед настройкой любой анимации. В этом методе представление привязано, но ориентация еще не установлена. Вы можете переопределить этот метод для выполнения пользовательских задач, связанных с отображением представления, таких как скрытие полей или отключение действий до того, как представление станет видимым.

### ViewWillLayoutSubviews

По умолчанию ничего не делает. Когда границы представления изменяются, представление корректирует положение своих подпредставлений. Контроллер представления может переопределить этот метод, чтобы внести изменения до того, как представление разместит свои подпредставления.

### Update constraints

### ViewDidLayoutSubviews

Этот метод вызывается после того, как viewController приспосабливается к своему подпредставлению после изменения его границы. Добавьте сюда код, если вы хотите внести изменения в подпредставления после того, как они были установлены.

### ViewDidAppear

Этот метод вызывается после представления, присутствующего на экране. Обычно сохраняют данные в основные данные, или запускают анимацию, или запускают воспроизведение видео или звука, или начинают сбор данных из сети. Этот тип задачи подходит для этого метода.

### ViewWillDissapear

Этот метод вызывается перед удалением представления из иерархии представлений. Представление все еще находится в иерархии представлений, но еще не удалено. любые анимации выгрузки еще не настроены. Добавьте сюда код для обработки таймеров, скрытия клавиатуры, отмены сетевых запросов, отмены любых изменений в родительском пользовательском интерфейсе. Также это идеальное место для сохранения состояния.

### ViewDidDissapear

Этот метод вызывается после удаления представления VC из иерархии представлений. Используйте этот метод, чтобы перестать прослушивать уведомления или датчики устройства.

### ViewWillTransition

Когда ориентация интерфейса изменяется, UIKit вызывает этот метод в корневом контроллере представления окна, прежде чем будут сделаны изменения размера. Затем корневой контроллер представления уведомляет свои дочерние контроллеры представления, распространяя сообщение по всей иерархии контроллеров представления.Theсодержит новый размер представления контейнера CGSize, а параметр содержит координатор UIViewControllerTransitionCoordinator, перечисление, описывающее новую ориентацию.


## UIKit

Вспомним, что же было до появления iPhone. Были маки – компьютеры на операционной системе macOS. Сейчас для нас очевидно, что это 2 разных пользовательских опыта – тыкать пальцем в экран и елозить мышкой по столу + стучать по клавишам на клавиатуре, но тогда перед инженерами Apple стояла задача взять механизм отрисовки интерфейса из мака и научить его в «Мультитач». И вот, что получилось:

![image](https://hsto.org/r/w1560/getpro/habr/upload_files/680/9c4/713/6809c47136bfb7ec8e7fae31fd8fcc92.png)

Четкое разделение ответственности (привет, SOLID) позволило не дублировать код, а просто добавить новую надстройку, которая будет распознавать пользовательские жесты и обрабатывать их. А слой, который отвечает за отрисовку, остался общим. Круто? Круто!
Итак, мы видим, что верхним уровнем в случае iOS является UIKit, в случае macOS - AppKit. Этот уровень отвечает за распознавание пользовательских активностей (тач пальцем в область экрана или наведение курсора мышки на какой-то элемент). Ниже лежит Core Animation, вот он-то и отвечает за то, что мы видим на экране и каким будет каждый элемент.

### Кстати, до версий Mac OS X 10.5 и iPhoneOS 2.0 CoreAnimation носил менее ориентированное на анимацию название – LayerKit.

Несмотря на то, что Core Animation отвечает за графический интерфейс, отрисовкой контента занимается не он. Эту функцию выполняют более низкоуровневые фреймворки Core Graphics и Metal, с той лишь разницей, что Core Graphics для вычислений использует CPU, а Metal - GPU.
Грубо говоря, Core Animation отвечает на вопрос «Что рисовать?», а Core Graphics и Metal - «Как рисовать?». Можем ли мы работать напрямую с этими фреймворками? Можем. Это даже положительно скажется на производительности нашего приложения, но очень сильно увеличит стоимость разработки. То, что мы можем сделать в UIKit или Core Animation за пару строк кода, в Core Graphics или Metal может занять десятки. Важно понимать, как это устроено, однако использование не всегда оправданно.

![image](https://hsto.org/getpro/habr/upload_files/2f0/913/ac8/2f0913ac85cb2e2a97555a24d5474195.png)

### Responder Chain

Часто можно услышать, что базовым классом UIKit является UIView. Однако, если мы посмотрим на его реализацию, то увидим, что он является наследником UIResponder, что говорит о многом в назначении UIKit. 
Респондер – это тот, кто отвечает на пользовательские жесты. Но как наша вью узнает, что пользователь нажал именно на нее и что ей нужно обработать этот экшн? Здесь нам на помощь приходит механизм Responder Chain. 
Когда пользователь нажимает на экран это событие попадает в наше приложение (объект UIApplication). Дальше оно отправляется в UIWindow, где и запускается цепочка поиска firstResponder’а, в границах которого и было произведено нажатие. Цепочка запускается рекурсивным вызовом метода по всей иерархии дочерних вью:

```
  open func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView?
  
  ```
  
  Метод, который банально проверяет, находится ли точка в границах вью:
  
  ```
  open func point(inside point: CGPoint, with event: UIEvent?) -> Bool
  
  ```
  
  Если точка находится внутри вью, поиск продолжается уже среди своих дочерних вью, вызывая метод hitTest у них. Так продолжается пока не будет найдена самая нижняя в иерархии (самая верхняя на экране) вью, в которую попадает нажатие.
Если точка не находится внутри вью – возвращается nil.

Таким образом, наше корневое окно (объект UIWindow) находит вью-ферстреспондера и вызывает у него соответствующие методы:
  
  ```
 	open func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?)
	open func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?)   
	open func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?)   
	open func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?)
  
  ```
